<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Constellation Star Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0D0B1A; color: #eee; font-family: 'Inter', system-ui, sans-serif; }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    background: rgba(13,11,26,0.95); backdrop-filter: blur(8px);
    padding: 8px 16px; display: flex; align-items: center; gap: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    flex-wrap: wrap;
  }
  #toolbar label { font-size: 13px; color: #aaa; }
  #toolbar select, #toolbar button {
    background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
    color: #eee; padding: 4px 10px; border-radius: 4px; font-size: 13px; cursor: pointer;
  }
  #toolbar select[multiple] {
    padding: 2px 4px; height: auto; max-height: 160px; min-width: 120px;
  }
  #toolbar select[multiple] option {
    padding: 2px 6px; border-radius: 2px;
  }
  #toolbar select[multiple] option:checked {
    background: linear-gradient(135deg, rgba(196,113,237,0.4), rgba(246,79,89,0.4));
  }
  #toolbar button:hover { background: rgba(255,255,255,0.15); }
  #toolbar button.primary { background: linear-gradient(135deg, #C471ED, #F64F59); border: none; font-weight: 600; }
  #toolbar .sep { width: 1px; height: 20px; background: rgba(255,255,255,0.15); }
  canvas { display: block; cursor: crosshair; }
  #output-panel {
    position: fixed; right: 0; top: 46px; bottom: 0; width: 420px;
    background: rgba(13,11,26,0.97); border-left: 1px solid rgba(255,255,255,0.1);
    overflow-y: auto; z-index: 10; display: none;
  }
  #output-panel.open { display: block; }
  #output-panel pre {
    font-size: 11px; line-height: 1.5; padding: 12px; color: #C471ED;
    white-space: pre-wrap; word-break: break-all;
  }
  #output-panel .header {
    padding: 8px 12px; background: rgba(255,255,255,0.04);
    border-bottom: 1px solid rgba(255,255,255,0.08);
    font-size: 12px; font-weight: 600; display: flex; justify-content: space-between;
  }
  #status {
    position: fixed; bottom: 12px; left: 12px; z-index: 10;
    font-size: 12px; color: rgba(255,255,255,0.5); pointer-events: none;
  }
  #ref-image { display: none; }

  /* Hero content overlay */
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
  #hero-overlay {
    position: fixed; top: 46px; left: 0; right: 0; bottom: 0;
    display: flex; align-items: center; justify-content: center;
    pointer-events: none; z-index: 5;
    font-family: 'Inter', system-ui, sans-serif;
    opacity: 0.4;
  }
  #hero-overlay.hidden { display: none; }
  #hero-overlay .hero-content {
    text-align: center; max-width: 640px; padding: 0 20px;
  }
  #hero-overlay .hero-icon {
    width: clamp(80px, 15vw, 120px); height: clamp(80px, 15vw, 120px);
    margin-bottom: 24px;
    filter: drop-shadow(0 0 40px rgba(196, 113, 237, 0.3));
  }
  #hero-overlay .hero-title {
    font-size: clamp(2.5rem, 8vw, 3.75rem); font-weight: 700;
    letter-spacing: -0.02em; margin-bottom: 12px; color: #EEEAF2;
  }
  #hero-overlay .hero-tagline {
    font-size: clamp(1.125rem, 3vw, 1.5rem); font-weight: 500;
    margin-bottom: 8px;
    background: linear-gradient(135deg, #C471ED, #F64F59);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  #hero-overlay .hero-subtitle {
    font-size: clamp(0.9375rem, 2vw, 1.125rem); color: #A8A0B0;
    margin-bottom: 36px;
  }
  #hero-overlay .hero-ctas {
    display: flex; gap: 16px; justify-content: center; flex-wrap: wrap;
  }
  #hero-overlay .btn {
    display: inline-flex; align-items: center; justify-content: center;
    padding: 12px 28px; border-radius: 8px; font-size: 1rem;
    font-weight: 600; border: none; cursor: default;
  }
  #hero-overlay .btn-primary {
    background: linear-gradient(135deg, #C471ED, #F64F59); color: #fff;
    box-shadow: 0 4px 16px rgba(196, 113, 237, 0.25);
  }
  #hero-overlay .btn-ghost {
    background: transparent; color: #EEEAF2;
    border: 1.5px solid rgba(255,255,255,0.08);
  }
  #hero-overlay .hero-scroll {
    position: absolute; bottom: 32px; left: 50%;
    transform: translateX(-50%); color: #A8A0B0; opacity: 0.5;
  }
</style>
</head>
<body>

<div id="toolbar">
  <label>Focus:</label>
  <select id="focus-select" multiple size="9" title="Ctrl+click to multi-select"></select>
  <div class="sep"></div>
  <label>Reference:</label>
  <button id="btn-ref">Load Image</button>
  <input type="file" id="ref-input" accept="image/*" style="display:none">
  <input type="range" id="ref-opacity" min="0" max="100" value="30" style="width:80px" title="Reference opacity">
  <div class="sep"></div>
  <button id="btn-add-star">+ Add Star</button>
  <button id="btn-del-star">- Delete Star</button>
  <div class="sep"></div>
  <button id="btn-hero">Hero Overlay</button>
  <input type="range" id="hero-opacity" min="0" max="100" value="40" style="width:80px" title="Hero overlay opacity">
  <div class="sep"></div>
  <button id="btn-export" class="primary">Export JS</button>
  <button id="btn-copy" class="primary">Copy to Clipboard</button>
</div>

<canvas id="canvas"></canvas>
<img id="ref-image">

<div id="hero-overlay">
  <div class="hero-content">
    <svg class="hero-icon" viewBox="0 0 512 512" aria-hidden="true">
      <defs>
        <linearGradient id="hero-bg" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0" stop-color="#C471ED"/><stop offset="1" stop-color="#F64F59"/>
        </linearGradient>
        <radialGradient id="hero-glow">
          <stop offset="0" stop-color="#fff" stop-opacity="0.8"/>
          <stop offset="0.5" stop-color="#fff" stop-opacity="0.3"/>
          <stop offset="1" stop-color="#fff" stop-opacity="0"/>
        </radialGradient>
      </defs>
      <circle cx="256" cy="256" r="256" fill="url(#hero-bg)"/>
      <path stroke="#fff" stroke-width="4.5" fill="none" stroke-linecap="round" opacity="0.6" d="M93.53 128.431C94.162 128.471 271.37 194.336 271.29 193.077"/>
      <path stroke="#fff" stroke-width="4.5" fill="none" stroke-linecap="round" opacity="0.6" d="M270.75 193.487C270.902 226.855 231.12 378.151 216.617 402.841"/>
      <path stroke="#fff" stroke-width="4.5" fill="none" stroke-linecap="round" opacity="0.6" d="M270.923 193.326C281.938 183.739 347.714 144.654 356.069 139.108"/>
      <circle cx="406.658" cy="182.257" r="20.163" fill="url(#hero-glow)"/>
      <circle cx="406.658" cy="182.257" r="9" fill="#fff"/>
      <circle cx="356.658" cy="138.257" r="28.322" fill="url(#hero-glow)"/>
      <circle cx="356.658" cy="138.257" r="10.837" fill="#fff"/>
      <circle cx="270.658" cy="193.257" r="16" fill="url(#hero-glow)"/>
      <circle cx="270.658" cy="193.257" r="6.5" fill="#fff"/>
      <circle cx="214.658" cy="403.257" r="16" fill="url(#hero-glow)"/>
      <circle cx="214.658" cy="403.257" r="6.5" fill="#fff"/>
      <circle cx="93.506" cy="128.312" r="13" fill="url(#hero-glow)"/>
      <circle cx="93.506" cy="128.312" r="5" fill="#fff"/>
      <path stroke="#fff" stroke-width="4.5" fill="none" stroke-linecap="round" opacity="0.6" d="M405.781 182.043C381.14 160.276 371.817 147.932 356.85 138.219"/>
      <circle cx="230.634" cy="178.62" r="11.949" fill="url(#hero-glow)"/>
      <circle cx="230.634" cy="178.62" r="5.334" fill="#fff"/>
    </svg>
    <h1 class="hero-title">Columba</h1>
    <p class="hero-tagline">Message freely. No internet required.</p>
    <p class="hero-subtitle">Encrypted mesh messaging over Bluetooth, WiFi, LoRa, and beyond.</p>
    <div class="hero-ctas">
      <span class="btn btn-primary">Download for Android</span>
      <span class="btn btn-ghost">View on GitHub</span>
    </div>
  </div>
  <div class="hero-scroll">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
  </div>
</div>

<div id="output-panel">
  <div class="header">
    <span>constellation-data.js — CONSTELLATION_DATA array</span>
    <button id="btn-close-panel" style="background:none;border:none;color:#aaa;cursor:pointer;font-size:16px">&times;</button>
  </div>
  <pre id="output-code"></pre>
</div>

<div id="status">Drag stars. Ctrl+click: multi-select. Alt+drag/scroll: move/rotate selected. Shift+drag/scroll: move/resize ref. Ctrl+Shift+scroll: rotate ref. D: labels.</div>

<script src="../js/constellation-data.js"></script>
<script>
(function() {
  'use strict';

  // ── Constellation data (loaded from shared constellation-data.js) ──
  var CONSTELLATIONS = CONSTELLATION_DATA;

  // ── Projection (same as constellation.js) ──
  var CENTER_RA = 95;
  var CENTER_DEC = -29;
  var COS_CENTER = Math.cos(CENTER_DEC * Math.PI / 180);

  function projectSky(ra, dec) {
    return { x: -(ra - CENTER_RA) * COS_CENTER, y: -(dec - CENTER_DEC) };
  }
  function unprojectSky(sx, sy) {
    return { ra: CENTER_RA - sx / COS_CENTER, dec: CENTER_DEC - sy };
  }

  // ── Canvas state ──
  var canvas = document.getElementById('canvas');
  var ctx = canvas.getContext('2d');
  var width, height;
  var skyMin = { x: Infinity, y: Infinity };
  var skyMax = { x: -Infinity, y: -Infinity };
  var scale, ox, oy;
  var dragStar = null;
  var dragConst = null;
  var hoverStar = null;
  var hoverConst = null;
  var showDebug = true;
  var focusConst = [];  // array of selected constellation names (empty = all)
  var addMode = false;
  var deleteMode = false;
  var panelOpen = false;

  // Reference image (drawn on canvas for repositioning)
  var refImg = document.getElementById('ref-image');
  var refVisible = false;
  var refOpacity = 0.3;
  var refX = 0;          // canvas X of top-left corner
  var refY = 0;          // canvas Y of top-left corner
  var refW = 0;          // displayed width
  var refH = 0;          // displayed height
  var refNatW = 0;       // natural image width
  var refNatH = 0;       // natural image height
  var refAngle = 0;      // rotation in radians
  var refDragging = false;
  var refDragStartX = 0;
  var refDragStartY = 0;
  var refDragOrigX = 0;
  var refDragOrigY = 0;

  // Group drag/rotate (Alt+drag / Alt+scroll in focus mode)
  var groupDragging = false;
  var groupDragStartX = 0;
  var groupDragStartY = 0;
  var groupOrigPositions = null;  // snapshot of sky coords at drag start

  function magToRadius(mag) {
    if (mag < 0) return 6;
    if (mag < 2) return 5;
    if (mag < 3) return 4;
    if (mag < 4) return 3;
    return 2.5;
  }

  function computeBounds() {
    skyMin.x = Infinity; skyMin.y = Infinity;
    skyMax.x = -Infinity; skyMax.y = -Infinity;
    for (var c = 0; c < CONSTELLATIONS.length; c++) {
      var con = CONSTELLATIONS[c];
      for (var s = 0; s < con.stars.length; s++) {
        var sky = projectSky(con.stars[s].ra, con.stars[s].dec);
        con.stars[s]._sx = sky.x;
        con.stars[s]._sy = sky.y;
        if (sky.x < skyMin.x) skyMin.x = sky.x;
        if (sky.x > skyMax.x) skyMax.x = sky.x;
        if (sky.y < skyMin.y) skyMin.y = sky.y;
        if (sky.y > skyMax.y) skyMax.y = sky.y;
      }
    }
    var px = (skyMax.x - skyMin.x) * 0.08;
    var py = (skyMax.y - skyMin.y) * 0.08;
    skyMin.x -= px; skyMax.x += px;
    skyMin.y -= py; skyMax.y += py;
  }

  function resize() {
    var panelW = panelOpen ? 420 : 0;
    width = window.innerWidth - panelW;
    height = window.innerHeight - 46;
    canvas.width = width;
    canvas.height = height;
    canvas.style.marginTop = '46px';
    computeBounds();
    var sw = skyMax.x - skyMin.x;
    var sh = skyMax.y - skyMin.y;
    var pad = 0.05;
    var uw = width * (1 - 2 * pad);
    var uh = height * (1 - 2 * pad);
    scale = Math.min(uw / sw, uh / sh);
    ox = (width - sw * scale) / 2;
    oy = (height - sh * scale) / 2;
  }

  function skyToCanvas(sx, sy) {
    return {
      x: ox + (sx - skyMin.x) * scale,
      y: oy + (sy - skyMin.y) * scale,
    };
  }
  function canvasToSky(cx, cy) {
    return {
      x: (cx - ox) / scale + skyMin.x,
      y: (cy - oy) / scale + skyMin.y,
    };
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Reference image (behind everything)
    if (refVisible && refImg.complete && refImg.naturalWidth > 0) {
      ctx.save();
      ctx.globalAlpha = refOpacity;
      // Rotate around image center
      var rcx = refX + refW / 2;
      var rcy = refY + refH / 2;
      ctx.translate(rcx, rcy);
      ctx.rotate(refAngle);
      ctx.drawImage(refImg, -refW / 2, -refH / 2, refW, refH);
      ctx.restore();
      // Border outline so you can see bounds when dragging/rotating
      if (refDragging) {
        ctx.save();
        ctx.translate(rcx, rcy);
        ctx.rotate(refAngle);
        ctx.strokeStyle = 'rgba(196,113,237,0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(-refW / 2, -refH / 2, refW, refH);
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    // Grid lines for RA/Dec
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    ctx.font = '10px monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    for (var ra = 60; ra <= 170; ra += 10) {
      var sky = projectSky(ra, CENTER_DEC);
      var p = skyToCanvas(sky.x, sky.y);
      ctx.beginPath();
      ctx.moveTo(p.x, 0);
      ctx.lineTo(p.x, height);
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('RA ' + ra + '°', p.x, 4);
    }
    for (var dec = -75; dec <= -10; dec += 5) {
      var sky = projectSky(CENTER_RA, dec);
      var p = skyToCanvas(sky.x, sky.y);
      ctx.beginPath();
      ctx.moveTo(0, p.y);
      ctx.lineTo(width, p.y);
      ctx.stroke();
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('Dec ' + dec + '°', 4, p.y);
    }

    // Draw constellations
    for (var c = 0; c < CONSTELLATIONS.length; c++) {
      var con = CONSTELLATIONS[c];
      var dimmed = focusConst.length > 0 && focusConst.indexOf(con.name) === -1;
      var alpha = dimmed ? 0.15 : 1.0;

      // Lines
      for (var l = 0; l < con.lines.length; l++) {
        var a = con.stars[con.lines[l][0]];
        var b = con.stars[con.lines[l][1]];
        var pa = skyToCanvas(a._sx, a._sy);
        var pb = skyToCanvas(b._sx, b._sy);
        ctx.beginPath();
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
        if (con.primary) {
          var lg = ctx.createLinearGradient(pa.x, pa.y, pb.x, pb.y);
          lg.addColorStop(0, 'rgba(196,113,237,' + (0.5 * alpha) + ')');
          lg.addColorStop(1, 'rgba(246,79,89,' + (0.5 * alpha) + ')');
          ctx.strokeStyle = lg;
          ctx.lineWidth = 2;
        } else {
          ctx.strokeStyle = 'rgba(255,255,255,' + (0.3 * alpha) + ')';
          ctx.lineWidth = 1.5;
        }
        ctx.stroke();
      }

      // Stars
      for (var s = 0; s < con.stars.length; s++) {
        var star = con.stars[s];
        var p = skyToCanvas(star._sx, star._sy);
        var r = magToRadius(star.mag);
        var isHover = (hoverConst === c && hoverStar === s);
        var isDrag = (dragConst === c && dragStar === s);

        // Glow
        var g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
        g.addColorStop(0, 'rgba(255,255,255,' + (0.3 * alpha) + ')');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, r * 3, 0, 6.283);
        ctx.fillStyle = g;
        ctx.fill();

        // Core
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, 6.283);
        ctx.fillStyle = isDrag ? '#F64F59' : isHover ? '#C471ED' : 'rgba(255,255,255,' + (0.9 * alpha) + ')';
        ctx.fill();

        // Hover ring
        if (isHover || isDrag) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 4, 0, 6.283);
          ctx.strokeStyle = isDrag ? '#F64F59' : '#C471ED';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Labels
        if (showDebug && !dimmed) {
          ctx.font = '600 11px monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'bottom';
          var txt = '[' + s + '] ' + star.label;
          var tw = ctx.measureText(txt).width;
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(p.x + r + 4, p.y - 14, tw + 6, 16);
          ctx.fillStyle = con.primary ? '#C471ED' : '#8CF';
          ctx.fillText(txt, p.x + r + 7, p.y - 1);

          // Coordinates below
          var coord = 'RA=' + star.ra.toFixed(2) + ' Dec=' + star.dec.toFixed(2);
          ctx.font = '10px monospace';
          var cw = ctx.measureText(coord).width;
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(p.x + r + 4, p.y, cw + 6, 13);
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillText(coord, p.x + r + 7, p.y + 11);
        }
      }

      // Constellation name
      if (!dimmed) {
        var cx = 0, maxY = -Infinity;
        for (var s = 0; s < con.stars.length; s++) {
          var p = skyToCanvas(con.stars[s]._sx, con.stars[s]._sy);
          cx += p.x;
          if (p.y > maxY) maxY = p.y;
        }
        cx /= con.stars.length;
        ctx.font = (con.primary ? '700 14px' : '600 12px') + ' Inter,system-ui,sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = con.primary ? 'rgba(196,113,237,0.6)' : 'rgba(255,255,255,0.3)';
        ctx.fillText(con.name, cx, maxY + 20);
      }
    }

    // Mode indicators
    if (addMode) {
      ctx.font = '600 14px Inter,system-ui,sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#2A9F2D';
      ctx.fillText('ADD MODE — Click to place a new star (Esc to cancel)', width / 2, 10);
    }
    if (deleteMode) {
      ctx.font = '600 14px Inter,system-ui,sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#F64F59';
      ctx.fillText('DELETE MODE — Click a star to remove it (Esc to cancel)', width / 2, 10);
    }
  }

  function findStar(mx, my) {
    var best = null, bestDist = 20;
    for (var c = 0; c < CONSTELLATIONS.length; c++) {
      if (focusConst.length > 0 && focusConst.indexOf(CONSTELLATIONS[c].name) === -1) continue;
      for (var s = 0; s < CONSTELLATIONS[c].stars.length; s++) {
        var star = CONSTELLATIONS[c].stars[s];
        var p = skyToCanvas(star._sx, star._sy);
        var d = Math.sqrt((p.x - mx) * (p.x - mx) + (p.y - my) * (p.y - my));
        if (d < bestDist) {
          bestDist = d;
          best = { c: c, s: s };
        }
      }
    }
    return best;
  }

  // ── Event handlers ──
  canvas.addEventListener('mousedown', function(e) {
    var mx = e.offsetX, my = e.offsetY;

    // Shift+click: start dragging reference image
    if (e.shiftKey && refVisible) {
      refDragging = true;
      refDragStartX = mx;
      refDragStartY = my;
      refDragOrigX = refX;
      refDragOrigY = refY;
      canvas.style.cursor = 'move';
      return;
    }

    // Alt+click: start group drag (requires at least one focused constellation)
    if (e.altKey && focusConst.length > 0) {
      groupDragging = true;
      groupDragStartX = mx;
      groupDragStartY = my;
      // Snapshot positions for ALL focused constellations
      groupOrigPositions = {};
      for (var fi = 0; fi < focusConst.length; fi++) {
        var ci = CONSTELLATIONS.findIndex(function(c) { return c.name === focusConst[fi]; });
        if (ci >= 0) {
          groupOrigPositions[ci] = CONSTELLATIONS[ci].stars.map(function(s) {
            return { ra: s.ra, dec: s.dec, _sx: s._sx, _sy: s._sy };
          });
        }
      }
      canvas.style.cursor = 'move';
      return;
    }

    if (addMode && focusConst.length === 1) {
      var sky = canvasToSky(mx, my);
      var rd = unprojectSky(sky.x, sky.y);
      var ci = CONSTELLATIONS.findIndex(function(c) { return c.name === focusConst[0]; });
      if (ci >= 0) {
        var label = prompt('Star label (e.g. "α Car"):', 'new star');
        if (label !== null) {
          var mag = parseFloat(prompt('Magnitude:', '3.5')) || 3.5;
          CONSTELLATIONS[ci].stars.push({
            ra: parseFloat(rd.ra.toFixed(2)),
            dec: parseFloat(rd.dec.toFixed(2)),
            mag: mag,
            label: label,
          });
          computeBounds();
          draw();
        }
      }
      addMode = false;
      return;
    }

    if (deleteMode) {
      var hit = findStar(mx, my);
      if (hit) {
        var con = CONSTELLATIONS[hit.c];
        var idx = hit.s;
        if (confirm('Delete ' + con.name + '[' + idx + '] ' + con.stars[idx].label + '?')) {
          con.stars.splice(idx, 1);
          // Fix line indices
          con.lines = con.lines.filter(function(l) {
            return l[0] !== idx && l[1] !== idx;
          }).map(function(l) {
            return [l[0] > idx ? l[0] - 1 : l[0], l[1] > idx ? l[1] - 1 : l[1]];
          });
          computeBounds();
          draw();
        }
      }
      deleteMode = false;
      return;
    }

    var hit = findStar(mx, my);
    if (hit) {
      dragConst = hit.c;
      dragStar = hit.s;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', function(e) {
    var mx = e.offsetX, my = e.offsetY;

    // Dragging reference image
    if (refDragging) {
      refX = refDragOrigX + (mx - refDragStartX);
      refY = refDragOrigY + (my - refDragStartY);
      draw();
      document.getElementById('status').textContent =
        'Reference image: x=' + Math.round(refX) + ' y=' + Math.round(refY) +
        ' (' + Math.round(refW) + 'x' + Math.round(refH) + ')  —  Scroll to resize, release to place';
      return;
    }

    // Group dragging (multi-constellation)
    if (groupDragging && groupOrigPositions) {
      var startSky = canvasToSky(groupDragStartX, groupDragStartY);
      var nowSky = canvasToSky(mx, my);
      var dsx = nowSky.x - startSky.x;
      var dsy = nowSky.y - startSky.y;
      var dra = -dsx / COS_CENTER;
      var ddec = -dsy;
      for (var ci in groupOrigPositions) {
        var con = CONSTELLATIONS[ci];
        var orig = groupOrigPositions[ci];
        for (var s = 0; s < con.stars.length; s++) {
          con.stars[s].ra = parseFloat((orig[s].ra + dra).toFixed(2));
          con.stars[s].dec = parseFloat((orig[s].dec + ddec).toFixed(2));
          con.stars[s]._sx = orig[s]._sx + dsx;
          con.stars[s]._sy = orig[s]._sy + dsy;
        }
      }
      draw();
      document.getElementById('status').textContent =
        'Moving ' + focusConst.join(', ') + ': ΔRA=' + dra.toFixed(2) + '° ΔDec=' + ddec.toFixed(2) + '°';
      return;
    }

    if (dragStar !== null) {
      var sky = canvasToSky(mx, my);
      var rd = unprojectSky(sky.x, sky.y);
      var star = CONSTELLATIONS[dragConst].stars[dragStar];
      star.ra = parseFloat(rd.ra.toFixed(2));
      star.dec = parseFloat(rd.dec.toFixed(2));
      star._sx = sky.x;
      star._sy = sky.y;
      draw();
      updateStatus(star);
      return;
    }

    var hit = findStar(mx, my);
    if (hit) {
      hoverConst = hit.c;
      hoverStar = hit.s;
      canvas.style.cursor = 'grab';
      updateStatus(CONSTELLATIONS[hit.c].stars[hit.s]);
    } else {
      hoverConst = null;
      hoverStar = null;
      canvas.style.cursor = addMode ? 'crosshair' : deleteMode ? 'not-allowed' : 'default';
      var sky = canvasToSky(mx, my);
      var rd = unprojectSky(sky.x, sky.y);
      document.getElementById('status').textContent =
        'RA=' + rd.ra.toFixed(2) + '° Dec=' + rd.dec.toFixed(2) + '°';
    }
    draw();
  });

  canvas.addEventListener('mouseup', function() {
    if (refDragging) {
      refDragging = false;
      canvas.style.cursor = 'default';
      draw();
      return;
    }
    if (groupDragging) {
      groupDragging = false;
      groupOrigPositions = null;
      canvas.style.cursor = 'default';
      draw();
      return;
    }
    if (dragStar !== null) {
      dragStar = null;
      dragConst = null;
      canvas.style.cursor = 'default';
      draw();
    }
  });

  function updateStatus(star) {
    document.getElementById('status').textContent =
      star.label + '  RA=' + star.ra.toFixed(2) + '° Dec=' + star.dec.toFixed(2) + '° mag=' + star.mag.toFixed(2);
  }

  document.addEventListener('keydown', function(e) {
    if (e.key === 'd' || e.key === 'D') { showDebug = !showDebug; draw(); }
    if (e.key === 'Escape') { addMode = false; deleteMode = false; draw(); }
  });

  // ── Toolbar ──
  var sel = document.getElementById('focus-select');
  CONSTELLATIONS.forEach(function(con) {
    var opt = document.createElement('option');
    opt.value = con.name;
    opt.textContent = con.name;
    sel.appendChild(opt);
  });
  sel.addEventListener('change', function() {
    focusConst = Array.from(sel.selectedOptions).map(function(o) { return o.value; });
    draw();
  });

  document.getElementById('btn-add-star').addEventListener('click', function() {
    if (focusConst.length !== 1) {
      alert('Select exactly one constellation first (Focus dropdown).');
      return;
    }
    addMode = true;
    deleteMode = false;
  });

  document.getElementById('btn-del-star').addEventListener('click', function() {
    deleteMode = true;
    addMode = false;
  });

  // Hero overlay toggle
  var heroOverlay = document.getElementById('hero-overlay');
  document.getElementById('btn-hero').addEventListener('click', function() {
    heroOverlay.classList.toggle('hidden');
  });
  document.getElementById('hero-opacity').addEventListener('input', function(e) {
    heroOverlay.style.opacity = e.target.value / 100;
  });

  // Reference image
  document.getElementById('btn-ref').addEventListener('click', function() {
    document.getElementById('ref-input').click();
  });
  document.getElementById('ref-input').addEventListener('change', function(e) {
    var file = e.target.files[0];
    if (!file) return;
    var url = URL.createObjectURL(file);
    refImg.onload = function() {
      refNatW = refImg.naturalWidth;
      refNatH = refImg.naturalHeight;
      // Fit to canvas height, maintaining aspect ratio
      var aspect = refNatW / refNatH;
      refH = height;
      refW = refH * aspect;
      // Center horizontally
      refX = (width - refW) / 2;
      refY = 0;
      refVisible = true;
      draw();
    };
    refImg.src = url;
  });
  document.getElementById('ref-opacity').addEventListener('input', function(e) {
    refOpacity = e.target.value / 100;
    draw();
  });

  // Scroll: Shift=resize ref, Ctrl+Shift=rotate ref, Alt=rotate constellation
  canvas.addEventListener('wheel', function(e) {
    // Alt+scroll: rotate focused constellation(s)
    if (e.altKey && focusConst.length > 0) {
      e.preventDefault();
      var angle = (e.deltaY > 0 ? 1 : -1) * 0.02; // ~1.15° per tick
      // Compute centroid across ALL focused constellations
      var cx = 0, cy = 0, total = 0;
      for (var fi = 0; fi < focusConst.length; fi++) {
        var ci = CONSTELLATIONS.findIndex(function(c) { return c.name === focusConst[fi]; });
        if (ci < 0) continue;
        for (var s = 0; s < CONSTELLATIONS[ci].stars.length; s++) {
          cx += CONSTELLATIONS[ci].stars[s]._sx;
          cy += CONSTELLATIONS[ci].stars[s]._sy;
          total++;
        }
      }
      if (total === 0) return;
      cx /= total; cy /= total;
      // Rotate each star around shared centroid
      var cos = Math.cos(angle), sin = Math.sin(angle);
      for (var fi = 0; fi < focusConst.length; fi++) {
        var ci = CONSTELLATIONS.findIndex(function(c) { return c.name === focusConst[fi]; });
        if (ci < 0) continue;
        for (var s = 0; s < CONSTELLATIONS[ci].stars.length; s++) {
          var dx = CONSTELLATIONS[ci].stars[s]._sx - cx;
          var dy = CONSTELLATIONS[ci].stars[s]._sy - cy;
          var nx = dx * cos - dy * sin + cx;
          var ny = dx * sin + dy * cos + cy;
          CONSTELLATIONS[ci].stars[s]._sx = nx;
          CONSTELLATIONS[ci].stars[s]._sy = ny;
          var rd = unprojectSky(nx, ny);
          CONSTELLATIONS[ci].stars[s].ra = parseFloat(rd.ra.toFixed(2));
          CONSTELLATIONS[ci].stars[s].dec = parseFloat(rd.dec.toFixed(2));
        }
      }
      draw();
      document.getElementById('status').textContent =
        'Rotating ' + focusConst.join(', ') + ': ' + (angle > 0 ? '+' : '') + (angle * 180 / Math.PI).toFixed(1) + '°';
      return;
    }

    if (!refVisible || !e.shiftKey) return;
    e.preventDefault();

    // Ctrl+Shift+scroll: rotate reference image
    if (e.ctrlKey) {
      var step = (e.deltaY > 0 ? 1 : -1) * 0.02;
      refAngle += step;
      draw();
      document.getElementById('status').textContent =
        'Reference image rotation: ' + (refAngle * 180 / Math.PI).toFixed(1) + '°';
      return;
    }

    // Shift+scroll: resize reference image (anchored at cursor)
    var mx = e.offsetX, my = e.offsetY;
    var factor = e.deltaY < 0 ? 1.08 : 1 / 1.08;
    var newW = refW * factor;
    var newH = refH * factor;
    var pctX = (mx - refX) / refW;
    var pctY = (my - refY) / refH;
    refX = mx - pctX * newW;
    refY = my - pctY * newH;
    refW = newW;
    refH = newH;
    draw();
    document.getElementById('status').textContent =
      'Reference image: ' + Math.round(refW) + 'x' + Math.round(refH) +
      ' (' + Math.round(refW / refNatW * 100) + '% scale)';
  }, { passive: false });

  // Export
  function generateJS() {
    var lines = [];
    for (var c = 0; c < CONSTELLATIONS.length; c++) {
      var con = CONSTELLATIONS[c];
      lines.push('    {');
      var props = "      name: '" + con.name + "'";
      if (con.primary) props += ', primary: true';
      props += ', side: ' + con.side + ',';
      lines.push(props);
      lines.push('      stars: [');
      for (var s = 0; s < con.stars.length; s++) {
        var star = con.stars[s];
        var label = (star.label || '').replace(/'/g, "\\'");
        lines.push("        { ra: " + star.ra.toFixed(2) + ", dec: " + star.dec.toFixed(2) + ", mag: " + star.mag.toFixed(2) + ", label: '" + label + "' },");
      }
      lines.push('      ],');
      var lineStrs = con.lines.map(function(l) { return '[' + l[0] + ',' + l[1] + ']'; });
      lines.push('      lines: [' + lineStrs.join(',') + '],');
      lines.push('    },');
    }
    return lines.join('\n');
  }

  document.getElementById('btn-export').addEventListener('click', function() {
    panelOpen = !panelOpen;
    document.getElementById('output-panel').classList.toggle('open');
    if (panelOpen) {
      document.getElementById('output-code').textContent = generateJS();
    }
    resize();
    draw();
  });

  document.getElementById('btn-copy').addEventListener('click', function() {
    var code = generateJS();
    navigator.clipboard.writeText(code).then(function() {
      var btn = document.getElementById('btn-copy');
      btn.textContent = 'Copied!';
      setTimeout(function() { btn.textContent = 'Copy to Clipboard'; }, 1500);
    });
  });

  document.getElementById('btn-close-panel').addEventListener('click', function() {
    panelOpen = false;
    document.getElementById('output-panel').classList.remove('open');
    resize();
    draw();
  });

  // ── Init ──
  window.addEventListener('resize', function() { resize(); draw(); });
  resize();
  draw();
})();
</script>
</body>
</html>
